# 파생(derive) - 기본의 클래스에 새로운 기능을 추가한 새로운 클래스


#include <iostream>

using namespace std;
enum BREED { YORKIE, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB};
class Mammal{
public:
    Mammal();
    ~Mammal();
    int GetAge() const {return itsAge;}
    void SetAge(int age) {itsAge = age;}
    int GerWeight() const {return itsWeight;}
    void SetWeight(int weight) {itsWeight=weight;}
    void Speak() const { cout << "Mammal sound!" << endl;}
    void Sleep() const { cout << "shhh. i'm sleeping" << endl;}
protected:
    int itsAge;
    int itsWeight;
};
class Dog : public Mammal{
public:
    Dog();
    ~Dog();
    BREED GetBreed() const { return itsBreed;}
    void SetBreed(BREED breeed) { itsBreed = breeed;}
    void WagTail() {cout << "Tail wagging..." << endl;}
    void BegForFood() {cout << "Begging for food..." << endl;}
private:
    BREED itsBreed;
};
Mammal::Mammal():
itsAge(1),
itsWeight(5){
    cout << "Mammal constructor..." << endl;
}
Mammal::~Mammal(){
    cout << "Mannal destructor..." << endl;
}
Dog::Dog():
itsBreed(YORKIE){
    cout<< "Dog constructor..." << endl;
}
Dog::~Dog(){
    cout<< "Dog destructor..." << endl;
}
int main() {
    Dog fido;
    fido.Speak();
    fido.WagTail();
    cout << "Fido is " << fido.GetAge() <<  " years old" << endl;
    return 0;
}
--------------------------------------------------------------------------------------
- 기본(base)클래스, 파생(derived) 클래스
- 상속 : public(0), protected(사용x), private(사용잘x)
- protected : 상속에서 사용

#include <iostream>

using namespace std;
enum BREED { YORKIE, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB};
class Mammal{
private: int ix; // Mammal 내부에서만 값이 확인된다.
protected: int ipr;
public: int ipu;
    //void getAge(){itsAge;}
};
class Dog : public Mammal { //public 상속 , private에는 접근이 불가하다.
    void getAge(){itsAge;}
};

class Dog{
private: int ix; // 접근 불가영역
protected: int ipr; // protected : int ipr;
public: int ipu; // public : int ipu;

private: int dx;
protected: int dpr;
public : int dpu;
}

class Dog : protected Mammal { //
    void getAge(){itsAge;}
};

class Dog{
private: int ix; // 접근 불가영역
protected: int ipr; // protected : int ipr;
public: int ipu; // protected : int ipu;

private: int dx;
protected: int dpr;
public : int dpu;
}

class Dog : private Mammal { //
    private: int dx;
    protected: int dpr;
    public : int dpu;
};
class Dog{
private: int ix; // 접근 불가영역
protected: int ipr; // private : int ipr;
public: int ipu; // private : int ipu;

private: int dx;
protected: int dpr;
public : int dpu;
}

int main() {
    Mammal m;
    m.itsAge;
}
--------------------------------------------------------------------------------------
# 함수 재생 (Overriding Function)
- 함수를 똑같이 선언해서 막아버리는 방식
#include <iostream>

using namespace std;
enum BREED { YORKIE, CAIRN, DANDIE, SHETLAND, DOBERMAN, LAB};

class Mammal{
public:
    Mammal(){cout<<"Mammal constructor..." << endl;}
    ~Mammal() {cout<< "Mammal destructor..." << endl;}
    void Speak()const { cout<< "Mammal sound!" << endl;}
    void sleep()const { cout<< "shhh. I'm sleeping" << endl;}
protected:
    int itsAge;
    int itsWeight;
};
class Dog : public Mammal{
public:
    Dog() {cout << "Dog constructor..." << endl;}
    ~Dog() {cout << "Dog destructor..." << endl;}
    void WagTail() { cout << "Tail wagging..." << endl;}
    void BegForFood() { cout << "Begging for good..." << endl;}
    void Speak()const{cout << "Woof!" << endl;}
private:
    BREED itsBredd;
};

int main() {
    Mammal bigAnimal;
    Dog fido;
    bigAnimal.Speak();
    fido.Speak();
    return 0;
}
---------------------------------------------------------------------------------------
# overloading(중첩), overriding(중첩)
- 중첩 : 같은 이름을 가지고 메쏘드를 만든다는 것.
- 재생 : 파생 클래스에서 베이스 클래스와 같은 이름, 같은 원형부르르 가진 메소드를 만듦.

#include <iostream>

using namespace std;

class Mammal{
public:
    void Move() const {cout << "Mammal move on step" << endl;}
    void Move(int distance) const{
        cout << "Mammal move";
        cout << distance << "_steps." << endl;
    }
protected:
    int itsAge;
    int itsWeight;
};
class Dog : public Mammal{
public:
    void Move() const { 
        cout << "Dog move 5 steps." << endl;
        //Mammal::Move(3);
};
int main() {
    Mammal bigAnimal;
    Dog fido;
    bigAnimal.Move();
    bigAnimal.Move(2);
    fido.Move();
    //fido.Mammal::Move(6);
    return 0;
}
----------------------------------------------------------------------------------------
#include <iostream>

using namespace std;

class USB { // interface
public:
    virtual void connect() = 0; // 순수 가상함수
    virtual void read() = 0;
};
class USBDisk : public USB{
public:
    virtual void connect(){cout << "USB Disk 연결" << endl;}
    virtual void read(){cout << "USB Disk 읽기" << endl;}
};
class USBMouse : public USB{
public:
    virtual void connect(){cout << "USB Mouse 연결" << endl;}
    virtual void read(){cout << "USB Mouse 읽기" << endl;}
};
class USBWifi : public USB{
public:
    virtual void connect(){cout << "USB Wifi 연결" << endl;}
    virtual void read(){cout << "USB Wifi 읽기" << endl;}
};
class DeskTop {
    USB* usb0;
    public:
    DeskTop() {}
    void connect(USB& rusb0){usb0 = &rusb0; usb0->connect(); usb0 -> read();}
};

int main() {
    DeskTop& myDeskTop = *new DeskTop();
    USBDisk& myUSBDisk = *new USBDisk();
    myDeskTop.connect(myUSBDisk);
    USBMouse& myUSBMouse = *new USBMouse();
    myDeskTop.connect(myUSBMouse);
    USBWifi& myUSBWifi = *new USBWifi();
    myDeskTop.connect(myUSBWifi);
    delete & myUSBDisk;
    delete & myDeskTop;
    return 0;
}
=======================================================================================
# 가상 메쏘드 (Virtual Method)
- 동자 구조를 보여준다.

//-d1reportSingleClassLayoutDog
//-d1reportSingleClassLayoutPuddle
//c1 main.cpp -c -d1reportSingleClassLayoutDog
//프로젝트>속성>c/c++>명령줄>추가옵션>/d1report-

1>main.cpp
1>class USBDisk	size(8):
1>	+---
1> 0	| +--- (base class USB)
1> 0	| | {vfptr}
1>	| +---
1>	+---
1>USBDisk::$vftable@:
1>	| &USBDisk_meta
1>	|  0
1> 0	| &USBDisk::connect
1> 1	| &USBDisk::read
----------------------------------------------------------------------------------------
#include <iostream>

using namespace std;

class Mammal
{
public:
    Mammal():itsAge(1) { cout << "Mammal constructor...\n"; }
    ~Mammal() { cout << "Mammal destructor...\n"; }
    void Move() const { cout << "Mammal move one step\n"; }
    virtual void Speak() const { cout << "Mammal speak!\n"; }
    protected:
    int itsAge;
};
class Dog : public Mammal
{
public:
    Dog() { cout << "Dog Constructor...\n"; }
    ~Dog() { cout << "Dog destructor...\n"; }
    void WagTail() { cout << "Wagging Tail...\n"; }
    void Speak()const { cout<< "Woof!\n"; }
    void Move()const { cout << "Dog moves 5 steps...\n"; }
};
int main() {
    Mammal *pDog = new Dog;
    pDog->Move();
    pDog->Speak();
    return 0;
}
----------------------------------------------------------------------------------------
#include <iostream>

using namespace std;

class Mammal{
public:
    Mammal():itsAge(1){}
    ~Mammal() {}
    virtual void Speak() const { cout << "Mammal speak!\n";}
protected:
    int itsAge;
};
class Dog : public Mammal{
public:
    void Speak() const {cout << "Woof!\n";}
};
class Cat : public Mammal{
public:
    void Speak() const {cout << "Meow!\n";}
};
class Horse : public Mammal{
public:
    void Speak() const {cout << "Winnie!\n";}
};
class Pig : public Mammal{
public:
    void Speak() const {cout << "Oink!\n";}
};
int main() {
    Mammal* theArray[5];
    Mammal* ptr;
    int choice, i;
    for ( i = 0; i<5; i++){
        cout << "(1)dog (2)cat (3)horse (4)pig:";
        cin >> choice;
        switch (choice){
            case 1: ptr = new Dog;
                        break;
            case 2: ptr = new Cat;
                        break;
            case 3: ptr = new Horse;
                        break;
            case 4: ptr = new Pig;
                        break;
        }
        theArray[i] = ptr;
    }
    for (i=0; i<5; i++)
                theArray[i] -> Speak();
    return 0;
}
---------------------------------------------------------------------------------------


















